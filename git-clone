#!/bin/sh
config="$HOME/.config/git-clone/config"

# usernames can have dots; sourced files cannot
encode_user () {
  echo "${1//\./DOT}"
}

update_or_add () {
  key="$1"
  value="$2"
  if ! [ -f "$config" ]; then
    folder="${config%/*}"
    mkdir -p "$folder"
  else
    # strip any existing value
    sed -i "" "/^${key}=/d" "$config"
  fi
  if [ -n "$value" ]; then
    echo "$key=$value" >> "$config"
  fi
}

get_username () {
  active_user="$1"
  if [ -z "$active_user" ]; then
    read -p "Git Username: " active_user
  fi
  read -s -p "Git Personal Access Token for $active_user: " token
  echo
  active_user_e="$(encode_user $active_user)"
  key="GIT_TOKEN_$active_user_e"
  update_or_add "$key" "$token"
  echo "$active_user"
}

edit_config () {
  usernames=()
  i=0
  options="Users:"
  message="Select default username (#"
  while read -r line; do
    line="${line%%=*}"
    name="${line##GIT_TOKEN_}"
    if ! [ "$name" == "$line" ]; then
      let i+=1
      usernames+=($name)
      if [ "$GIT_DEFAULT_USER" == "$name" ]; then
        message="$message or blank for '$name'"
        name="$name * (current default)"
        inuse=$i
      fi
      options="${options}\n - [$i] $name"
    fi # if we find unexpected lines, just skip 'em
  done < "$config"

  if [ "${#usernames[@]}" -eq 0 ]; then
    echo "No users to edit! Try adding a token with $me -u"
    exit
  else
    echo "$options"
    read -p "$message) " num
    [ -z "$num" ] && num=$inuse
    if [ -z "$num" ]; then
      echo "No user selected - exiting."
      exit
    else
      let num-=1
      username="${usernames[num]}"
      printf "Actions:\n  [1] Edit ${username}'s token\n  [2] Set ${username} as default\n  [3] Remove ${username} (NOT RECOVERABLE)\n"
      read -p "Select Action for $username: " action
      if [ -z "$action" ]; then
        echo "No action chosen"
      elif [ $action == '1' ] ; then
        get_username "$username" > /dev/null
      elif [ $action == '2' ] ; then
        update_or_add 'GIT_DEFAULT_USER' "$username"
      elif [ $action == '3' ] ; then
        update_or_add "GIT_TOKEN_$username"
      else
        echo "Input not recognized"
      fi
    fi
  fi
}

set_personal () {
  if [ -f "$HOME/.gitconfig.personal" ]; then
    read -p "Update global git user? (y/N)" global_git
  else
    global_git="y"
  fi

  if [[ $global_git =~ ^[yY] ]] ; then
    echo "Setting up global git information"
    read -p "Global git user name: " guser
    read -p "Global git user email: " gemail
    cat<<END > $HOME/dotfiles/.gitconfig.personal
[user]
  name = ${guser}
  email = ${gemail}
END
  fi
}

me="$(basename $0)"
usage="$me makes having multiple Gitb accounts more managable via
separate Pesrsonal Access Tokens, HTTPS repositories, hierarchical .gitconfigs,
and your OS's keychain.

-e[edit]      Update default and tokens
-g[itconfig]  Modify ~/.gitconfig.personal
-u[sername]   The git username to use
-b[branch]    Checks out a specific branch of the project before continuing
-r[ecurse]    Recursively checkout (for projects with submodules)"

if [ -f "$config" ]; then
  source "$config"
else
  ran_set="true"
  username=$(get_username "$username")
  set_default
  set_personal
fi

while getopts ':rgu:e:b:h' option; do
  case "$option" in
    h) echo "$usage"
      exit
      ;;
    e) username="$OPTARG"
      [ -z "$ran_set" ] && edit_config
      exit
      ;;
    g) [ -z "$ran_set" ] && set_personal
      exit
      ;;
    u) username="$OPTARG"
      ;;
    b) branch="$OPTARG"
      ;;
    r) recurse="deep"
      ;;
    *) echo "getoutahere with that $OPTARG"
      ;;
  esac
done
shift $((OPTIND -1))

repo="$1"
# support hub-style shortnames user-or-org/project for github
# shortnames are not supported for gitlab, bitbucket, etc.
if [[ "$repo" =~ ^[^/]*/[^/]*$ ]]; then
  repo="https://github.com/$repo"
fi

if [ -z "$repo" ]; then
  echo "[31mNo repo URL provided[0m"
  echo "$usage"
  exit
elif [ -z "$username" ]; then
  if [ -z "$GIT_DEFAULT_USER" ]; then
    username=$(get_username)
    set_default
    set_personal
  else
    username="$GIT_DEFAULT_USER"
  fi
fi

username_e=$(encode_user $username)

token_key="GIT_TOKEN_$username_e"
token="${!token_key}"

if [ -z "$token" ]; then
  get_username "$username" > /dev/null
  echo
fi

root=$(pwd)
# https://www.tldp.org/LDP/abs/html/string-manipulation.html
name=${repo##*/} # Deletes longest instance of * (anything)/ (the slash) from front
name=${name%.git} # Deletes shortest instance of ".git" from back
auth_repo=${repo/https:\/\//https://$username:$token@}
include="[include]
  path = ${root}/.gitconfig"
command="git clone"

message="You're checking out $repo as $username"
if [ -n "$branch" ]; then
  message="$message using $branch branch"
  command="$command -b $branch"
fi
command="$command $auth_repo"
if [ -n "$recurse" ]; then
  message="$message and with its submodules"
  command="$command --recurse-submodules"
fi

echo "$message"
$command
if [ $? -eq 0 ]; then
  cd "$name" || exit

  echo "$include" >> .git/config

  if [ -n "$recurse" ]; then
    git submodule update --init --recursive
    for D in $(find ./.git/modules -type d -maxdepth 1 ! -path ./.git/modules)
    do
      echo "$include" >> "$D/config"
    done
  fi
fi
